push 0
pop rbp
push 0
pop [99]
#{
jmp :function_fact_1*skip
function_fact_1:
#{
#begin of rcb 2
#Load var n to reg r2
push r2
push 0
#save
#reg 2 contains var n (@0)
push r2
pop [rbp + 0]
jeq :if_else_3
#src:
#Load var n to reg r2
push [rbp + 0]
pop r2
push r2
push 1
sub
push :function_fact_1
pop rax
#save
#reg 2 contains var n (@0)
push r2
pop [rbp + 0]
#call of func
push rbp
push 1 
add
pop rbp
pop r2
push [98]
push rbp
pop [98]
call rax
swap
pop [98]
push rbp
push 1 
sub
pop rbp
#end of func call
#Load var n to reg r2
push [rbp + 0]
pop r2
push r2
mul
#Esrc:
pop rax
jmp :eocb_2
jmp :if_end_3
#save
#reg 2 contains var n (@0)
push r2
pop [rbp + 0]
if_else_3:
#src:
push 1
#Esrc:
pop rax
jmp :eocb_2
if_end_3:
#save
eocb_2:
push rax
#}
swap
ret
function_fact_1*skip:
#src:
inp
push :function_fact_1
pop rax
#save
#call of func
push rbp
push 0 
add
pop rbp
pop r2
push [98]
push rbp
pop [98]
call rax
swap
pop [98]
push rbp
push 0 
sub
pop rbp
#end of func call
#Esrc:
out
halt
#}
