push 0
pop rbp
push 0
pop [99]
#{
#src:
push 100
#Esrc:
#Load var x to reg r2
pop r2
jmp :function_hell_1*skip
function_hell_1:
#{
#begin of rcb 2
#Load var t1 to reg r2
#Load var t2 to reg r3
#src:
push 666
#Esrc:
out
#src:
#Load var x to reg r4
push [99]
pop rax
push [rax + 0]
pop r4
push r4
#Esrc:
out
#src:
push r2
#Esrc:
out
#src:
push r3
#Esrc:
out
eocb_2:
push rax
#}
swap
ret
function_hell_1*skip:
jmp :v-function_ans_3*skip
v-function_ans_3:
#{
#begin of rcb 4
#src:
push 42
#Esrc:
pop rax
jmp :eocb_4
eocb_4:
push rax
#}
swap
ret
v-function_ans_3*skip:
push 13
push 11
push :function_hell_1
pop rax
#save
#reg 2 contains var x (@0)
push r2
pop [rbp + 0]
#call of func
push rbp
push 1 
add
pop rbp
pop r3
pop r2
push [98]
push rbp
pop [98]
call rax
swap
pop [98]
push rbp
push 1 
sub
pop rbp
#end of func call
pop rnn
#aset:
push 'H'
push 0
pop rnn
outch
push 'e'
push 0
pop rnn
outch
push 'l'
push 0
pop rnn
outch
push 'l'
push 0
pop rnn
outch
push 'o'
push 0
pop rnn
outch
push ' '
push 0
pop rnn
outch
push 'w'
push 0
pop rnn
outch
push 'o'
push 0
pop rnn
outch
push 'r'
push 0
pop rnn
outch
push 'l'
push 0
pop rnn
outch
push 'd'
push 0
pop rnn
outch
push 10
push 11
pop rnn
outch
#Easet:
#}
